/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_IMGUI_MAP_LAYERS_GUI
#define OSGEARTH_IMGUI_MAP_LAYERS_GUI

#include "ImGui"
#include <osgEarth/MapNode>
#include <osgEarth/EarthManipulator>
#include <osgEarth/ViewFitter>
#include <osgEarth/ThreeDTilesLayer>
#include <osgEarth/ImageLayer>
#include <osgEarth/MapboxGLImageLayer>
#include <osgEarth/FeatureModelLayer>
#include <osgEarth/TerrainConstraintLayer>
#include <osgEarth/NodeUtils>
#include <osgEarth/TerrainEngineNode>
#include <osgEarth/ExampleResources>
#include <osg/Camera>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#if defined(__has_include)
#if __has_include(<third_party/portable-file-dialogs/portable-file-dialogs.h>)
#include <third_party/portable-file-dialogs/portable-file-dialogs.h>
#define HAS_PFD
#endif
#endif

#include <osgEarth/Registry>
#include <osgEarth/XYZ>
#include <osgEarth/TMS>
#include <osgEarth/GDAL>
#include <osgEarth/WMS>
#include <osgEarth/DebugImageLayer>

#ifdef OSGEARTH_HAVE_MBTILES
#include <osgEarth/MBTiles>
#endif

namespace osgEarth {
    namespace GUI
    {
        using namespace osgEarth;
        using namespace osgEarth::Contrib;
        using namespace osgEarth::Util;

        struct AddWMSDialog
        {
            AddWMSDialog()
            {
                strcpy(url, "http://readymap.org/readymap/tiles");
                memset(name, 0, sizeof(name));
            }

            void draw(osgEarth::MapNode* mapNode)
            {
                if (!visible) return;

                ImGui::Begin("Add WMS", &visible);
                ImGui::InputText("URL", url, IM_ARRAYSIZE(url));
                const std::string wmsVersion = "1.1.1";

                if (ImGui::Button("Fetch layers from server"))
                {
                    std::string wmsString = std::string(url);
                    char sep = wmsString.find_first_of('?') == std::string::npos ? '?' : '&';

                    std::string capUrl = wmsString +
                        sep +
                        std::string("SERVICE=WMS") +
                        std::string("&VERSION=") + wmsVersion +
                        std::string("&REQUEST=GetCapabilities");

                    capabilities = WMS::CapabilitiesReader::read(capUrl, nullptr);
                }

                static ImGuiTableFlags flags = ImGuiTableFlags_ScrollY | ImGuiTableFlags_BordersV | ImGuiTableFlags_BordersOuterH | ImGuiTableFlags_Resizable | ImGuiTableFlags_RowBg | ImGuiTableFlags_NoBordersInBody;
                ImVec2 outer_size = ImVec2(0.0f, 300.0f);
                if (ImGui::BeginTable("wms_layers", 3, flags, outer_size))
                {
                    // The first column will use the default _WidthStretch when ScrollX is Off and _WidthFixed when ScrollX is On
                    ImGui::TableSetupColumn("Name", ImGuiTableColumnFlags_NoHide);
                    ImGui::TableSetupColumn("Title", ImGuiTableColumnFlags_NoHide);
                    ImGui::TableSetupColumn("Abstract", ImGuiTableColumnFlags_NoHide);
                    ImGui::TableHeadersRow();

                    if (capabilities.valid())
                    {
                        for (auto& layer : capabilities->getLayers())
                        {
                            displayWMSLayer(layer);
                        }
                    }
                    ImGui::EndTable();
                }

                ImGui::InputText("Name", name, IM_ARRAYSIZE(name));

                if (ImGui::Button("OK"))
                {
                    if (selectedWMSLayer)
                    {
                        WMSImageLayer* wms = new WMSImageLayer;
                        if (strlen(name) > 0)
                            wms->setName(name);
                        else
                            wms->setName(selectedWMSLayer->getTitle());
                        wms->setURL(url);
                        wms->setLayers(selectedWMSLayer->getName());
                        mapNode->getMap()->addLayer(wms);
                    }
                    visible = false;
                }

                ImGui::SameLine();
                if (ImGui::Button("Cancel"))
                {
                    visible = false;
                }
                ImGui::End();
            }

            void displayWMSLayer(WMS::Layer* layer)
            {
                ImGui::TableNextRow();
                ImGui::TableNextColumn();
                const bool is_folder = (layer->getLayers().size() > 0);
                if (is_folder)
                {
                    bool open = ImGui::TreeNodeEx(layer->getName().c_str(), ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_DefaultOpen);
                    ImGui::TableNextColumn();
                    ImGui::TextDisabled(layer->getTitle().c_str());
                    ImGui::TableNextColumn();
                    ImGui::Text(layer->getAbstract().c_str());
                    if (open)
                    {
                        for (auto& l : layer->getLayers())
                        {
                            displayWMSLayer(l);
                        }
                        ImGui::TreePop();
                    }
                }
                else
                {
                    ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_DefaultOpen;
                    if (layer == selectedWMSLayer)
                    {
                        node_flags |= ImGuiTreeNodeFlags_Selected;
                    }
                    ImGui::TreeNodeEx(layer->getName().c_str(), node_flags);
                    if (ImGui::IsItemClicked())
                    {
                        selectedWMSLayer = layer;
                        strcpy(name, selectedWMSLayer->getTitle().c_str());
                    }
                    ImGui::TableNextColumn();
                    ImGui::Text(layer->getTitle().c_str());
                    ImGui::TableNextColumn();
                    ImGui::Text(layer->getAbstract().c_str());
                }
            }

            bool visible = false;
            char url[128];
            char name[1024];
            osg::ref_ptr<WMS::Capabilities> capabilities;
            osg::ref_ptr< WMS::Layer > selectedWMSLayer;
        };


        struct AddTMSDialog
        {
            void draw(MapNode* mapNode)
            {
                if (!visible) return;

                ImGui::Begin("Add TMS", &visible);
                ImGui::InputText("Name", name, IM_ARRAYSIZE(name));
                ImGui::InputText("URL", url, IM_ARRAYSIZE(url));
                ImGui::Checkbox("Treat as Elevation", &isElevation);
                if (ImGui::Button("OK"))
                {
                    if (isElevation)
                    {
                        TMSElevationLayer* tms = new TMSElevationLayer;
                        tms->setName(name);
                        tms->setURL(url);
                        mapNode->getMap()->addLayer(tms);
                    }
                    else
                    {
                        TMSImageLayer* tms = new TMSImageLayer;
                        tms->setName(name);
                        tms->setURL(url);
                        mapNode->getMap()->addLayer(tms);
                    }
                    visible = false;
                }
                ImGui::SameLine();
                if (ImGui::Button("Cancel"))
                {
                    visible = false;
                }
                ImGui::End();
            }

            bool visible = false;
            char url[128] = "http://readymap.org/readymap/tiles/1.0.0/7/";
            char name[64] = "New Layer";
            bool isElevation = false;
        };

        struct AddXYZDialog
        {
            void draw(MapNode* mapNode)
            {
                if (!visible) return;

                ImGui::Begin("Add XYZ", &visible);
                ImGui::InputText("Name", name, IM_ARRAYSIZE(name));
                ImGui::InputText("URL", url, IM_ARRAYSIZE(url));

                static int profile = 1;
                ImGui::Text("Profile");
                if (ImGui::RadioButton("Global Geodetic", profile == 0)) { profile = 0; } ImGui::SameLine();
                if (ImGui::RadioButton("Spherical Mercator", profile == 1)) { profile = 1; }

                ImGui::Checkbox("Treat as Elevation", &isElevation);
                if (ImGui::Button("OK"))
                {
                    if (isElevation)
                    {
                        XYZElevationLayer* xyz = new XYZElevationLayer;
                        xyz->setName(name);
                        xyz->setURL(url);
                        if (profile == 0)      xyz->setProfile(osgEarth::Registry::instance()->getGlobalGeodeticProfile());
                        else if (profile == 1) xyz->setProfile(osgEarth::Registry::instance()->getSphericalMercatorProfile());
                        mapNode->getMap()->addLayer(xyz);
                    }
                    else
                    {
                        XYZImageLayer* xyz = new XYZImageLayer;
                        xyz->setName(name);
                        xyz->setURL(url);
                        if (profile == 0)      xyz->setProfile(osgEarth::Registry::instance()->getGlobalGeodeticProfile());
                        else if (profile == 1) xyz->setProfile(osgEarth::Registry::instance()->getSphericalMercatorProfile());
                        xyz->setProfile(osgEarth::Registry::instance()->getSphericalMercatorProfile());
                        mapNode->getMap()->addLayer(xyz);
                    }
                    visible = false;
                }
                ImGui::SameLine();
                if (ImGui::Button("Cancel"))
                {
                    visible = false;
                }
                ImGui::End();
            }

            bool visible = false;
            char url[128] = "http://[abc].tile.openstreetmap.org/{z}/{x}/{y}.png";
            char name[64] = "New Layer";
            bool isElevation = false;
        };

        class LayersGUI : public BaseGUI
        {
        private:
            osg::observer_ptr<MapNode> _mapNode;
            bool _showDisabled;
            LayerVector _layers;
            std::vector<bool> _layerExpanded;
            int _mapRevision;
            bool _first;
            std::unordered_map<Layer*, float> _maxMaxRanges;
            std::unordered_map<Layer*, float> _maxMinRanges;
            std::unordered_map<Layer*, float> _maxAttenRanges;
            bool _addXYZ = false;

            AddWMSDialog _addWMSDialog;
            AddTMSDialog _addTMSDialog;
            AddXYZDialog _addXYZDialog;

            ImageLayer* _queryLayer;
            using ValueUnderMouse = struct {
                osg::Vec4 pixel;
                GLenum pixelFormat;
            };
            Future<Result<ValueUnderMouse>> _imageLayerValueUnderMouse;

            std::function<bool(const Layer*)>
                _showPred,
                _showVisibleLayers,
                _showImageLayers,
                _showTerrainSurfaceLayers,
                _showFeatureModelLayers,
                _showConstraintLayers;

        public:

            LayersGUI() : BaseGUI("Map"),
                _showDisabled(false),
                _mapRevision(-1),
                _queryLayer(nullptr),
                _first(true)
            {
                _showVisibleLayers = [this](const Layer* layer)
                {
                    return
                        dynamic_cast<const VisibleLayer*>(layer) &&
                        layer->getUserProperty("show_in_ui", true);
                };

                _showImageLayers = [this](const Layer* layer)
                {
                    return
                        dynamic_cast<const ImageLayer*>(layer) &&
                        layer->getUserProperty("show_in_ui", true);
                };

                _showTerrainSurfaceLayers = [this](const Layer* layer)
                {
                    return
                        layer->getRenderType() == layer->RENDERTYPE_TERRAIN_SURFACE &&
                        layer->getUserProperty("show_in_ui", true);
                };

                _showFeatureModelLayers = [this](const Layer* layer)
                {
                    return
                        dynamic_cast<const FeatureModelLayer*>(layer) &&
                        layer->getUserProperty("show_in_ui", true);
                };

                _showConstraintLayers = [this](const Layer* layer)
                {
                    return
                        dynamic_cast<const TerrainConstraintLayer*>(layer) &&
                        layer->getUserProperty("show_in_ui", true);
                };

                _showPred = _showVisibleLayers;
            }

            //! Sets a predicate that decides whether to include a layer in the GUI
            void setShowPredicate(std::function<bool(const Layer*)> func)
            {
                _showPred = func;
            }

            void load(const Config& conf) override
            {
                conf.get("ShowDisabled", _showDisabled);
            }

            void save(Config& conf) override
            {
                conf.set("ShowDisabled", _showDisabled);
            }

            void usefulLayers()
            {
                if (ImGui::BeginMenu("Useful Layers"))
                {
                    // ReadyMap Imagery
                    if (ImGui::MenuItem("ReadyMap Imagery"))
                    {
                        TMSImageLayer* readymap = new TMSImageLayer();
                        readymap->setName("ReadyMap Imagery");
                        readymap->setURL("http://readymap.org/readymap/tiles/1.0.0/7/");
                        _mapNode->getMap()->addLayer(readymap);
                    }

                    // ReadyMap Elevation
                    if (ImGui::MenuItem("ReadyMap Elevation"))
                    {
                        TMSElevationLayer* readymap = new TMSElevationLayer();
                        readymap->setName("ReadyMap Elevation");
                        readymap->setURL("http://readymap.org/readymap/tiles/1.0.0/116/");
                        _mapNode->getMap()->addLayer(readymap);
                    }

                    // OpenStreetMap
                    if (ImGui::MenuItem("OpenStreetmap"))
                    {
                        XYZImageLayer* osm = new XYZImageLayer();
                        osm->setName("OpenStreetMap");
                        osm->setURL("http://[abc].tile.openstreetmap.org/{z}/{x}/{y}.png");
                        osm->setProfile(osgEarth::Registry::instance()->getSphericalMercatorProfile());
                        osm->setAttribution("&#169;OpenStreetMap contributors");
                        _mapNode->getMap()->addLayer(osm);
                    }

                    if (ImGui::MenuItem("Debug"))
                    {
                        DebugImageLayer* debugImage = new DebugImageLayer;
                        debugImage->setName("Debug");
                        _mapNode->getMap()->addLayer(debugImage);
                    }

                    ImGui::EndMenu();
                }
            }

            void draw(osg::RenderInfo& ri) override
            {
                if (!isVisible())
                    return;

                bool mapNodeWasValid = _mapNode.valid();

                if (!findNodeOrHide(_mapNode, ri))
                    return;

                if (_first)
                {
                    EventRouter::get(view(ri))
                        .onMove([&](osg::View* v, float x, float y) { onMove(v, x, y); });
                    _first = false;
                }

                const Map* map = _mapNode->getMap();

                Revision rev = map->getDataModelRevision();
                if (rev != _mapRevision || !mapNodeWasValid)
                {
                    _layers.clear();
                    _layerExpanded.clear();

                    if (_showPred)
                        _mapRevision = map->getLayers(_layers, _showPred);
                    else
                        _mapRevision = map->getLayers(_layers);

                    _layerExpanded.assign(_layers.size(), false);

                    _maxMaxRanges.clear();
                    _maxMinRanges.clear();
                    _maxAttenRanges.clear();
                    for (auto layer : _layers)
                    {
                        VisibleLayer* v = dynamic_cast<VisibleLayer*>(layer.get());
                        if (v)
                        {
                            _maxMaxRanges[layer.get()] = v->getMaxVisibleRange() * 2.0f;
                            _maxMinRanges[layer.get()] = v->getMinVisibleRange() * 2.0f;
                            _maxAttenRanges[layer.get()] = v->getAttenuationRange() * 2.0f;
                        }
                    }
                }

                osg::Camera* camera = ri.getCurrentCamera();

                ImGui::Begin(name(), visible(), ImGuiWindowFlags_MenuBar);
                {
                    if (ImGui::BeginMenuBar())
                    {
                        if (ImGui::BeginMenu("Add Layer"))
                        {
#ifdef HAS_PFD
                            if (ImGui::MenuItem("Local File"))
                            {
                                auto f = pfd::open_file("Choose files to read", pfd::path::home(),
                                    { "All Files", "*" },
                                    pfd::opt::multiselect);

                                if (f.result().size() > 0)
                                {
                                    auto m = pfd::message("Imagery",
                                        "Are these files imagery?  Select No for elevation.",
                                        pfd::choice::yes_no,
                                        pfd::icon::question);
                                    bool imagery = m.result() == pfd::button::yes;

                                    _mapNode->getMap()->beginUpdate();

                                    if (imagery)
                                    {
                                        for (auto const& name : f.result())
                                        {
                                            std::string ext = osgDB::getLowerCaseFileExtension(name);
                                            if (ext == "mbtiles")
                                            {
#ifdef OSGEARTH_HAVE_MBTILES
                                                MBTilesImageLayer* mbtilesImage = new MBTilesImageLayer;
                                                mbtilesImage->setName(osgDB::getSimpleFileName(name));
                                                mbtilesImage->setURL(name);
                                                _mapNode->getMap()->addLayer(mbtilesImage);
#else
                                                OE_WARN << "MBTiles driver not available" << std::endl;
#endif
                                            }
                                            else

                                            {
                                                GDALImageLayer* gdalImage = new GDALImageLayer;
                                                gdalImage->setName(osgDB::getSimpleFileName(name));
                                                gdalImage->setURL(name);
                                                _mapNode->getMap()->addLayer(gdalImage);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        for (auto const& name : f.result())
                                        {
                                            std::string ext = osgDB::getLowerCaseFileExtension(name);
                                            if (ext == "mbtiles")
                                            {
#ifdef OSGEARTH_HAVE_MBTILES
                                                MBTilesElevationLayer* mbtilesElevation = new MBTilesElevationLayer;
                                                mbtilesElevation->setName(osgDB::getSimpleFileName(name));
                                                mbtilesElevation->setURL(name);
                                                _mapNode->getMap()->addLayer(mbtilesElevation);
#else
                                                OE_WARN << "MBTiles driver not available" << std::endl;
#endif
                                            }
                                            else
                                            {
                                                GDALElevationLayer* gdalElevation = new GDALElevationLayer;
                                                gdalElevation->setName(osgDB::getSimpleFileName(name));
                                                gdalElevation->setURL(name);
                                                _mapNode->getMap()->addLayer(gdalElevation);
                                            }
                                        }
                                    }
                                    _mapNode->getMap()->endUpdate();
                                }
                            }


#endif

                            if (ImGui::MenuItem("TMS")) _addTMSDialog.visible = true;
                            if (ImGui::MenuItem("XYZ")) _addXYZDialog.visible = true;
                            if (ImGui::MenuItem("WMS")) _addWMSDialog.visible = true;

                            usefulLayers();

                            ImGui::EndMenu();
                        }
                        ImGui::EndMenuBar();
                    }

                    // Draw the add dialogs
                    _addXYZDialog.draw(_mapNode.get());
                    _addTMSDialog.draw(_mapNode.get());
                    _addWMSDialog.draw(_mapNode.get());

                    if (map->getName().empty() == false)
                    {
                        ImGui::TextColored(ImVec4(1, 1, 0, 1), map->getName().c_str());
                    }

                    static const char* filter_items[] = { "Visible layers", "Image layers", "Terrain surface", "Feature models", "Terrain constraints" };
                    static int filter_index = 0;
                    const char* filter_preview_value = filter_items[filter_index];
                    if (ImGui::BeginCombo("", filter_preview_value))
                    {
                        for (int n = 0; n < IM_ARRAYSIZE(filter_items); n++)
                        {
                            const bool is_selected = (filter_index == n);
                            if (ImGui::Selectable(filter_items[n], is_selected))
                            {
                                filter_index = n;
                                switch (filter_index) {
                                case 1: setShowPredicate(_showImageLayers); break;
                                case 2: setShowPredicate(_showTerrainSurfaceLayers); break;
                                case 3: setShowPredicate(_showFeatureModelLayers); break;
                                case 4: setShowPredicate(_showConstraintLayers); break;
                                default: setShowPredicate(_showVisibleLayers); break;
                                }
                                _mapRevision = -1; // force regen
                            }

                            // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
                            if (is_selected)
                                ImGui::SetItemDefaultFocus();
                        }
                        ImGui::EndCombo();
                    }

                    ImGui::SameLine();

                    if (ImGui::Checkbox("Disabled", &_showDisabled))
                        dirtySettings();

                    ImGui::Separator();

                    for (int i = _layers.size() - 1; i >= 0; --i)
                    {
                        osgEarth::Layer* layer = _layers[i].get();

                        if (!_showDisabled && !layer->isOpen() && !layer->getOpenAutomatically())
                            continue;

                        ImGui::PushID(layer);
                        bool stylePushed = false;

                        bool error =
                            layer->getStatus().isError() &&
                            layer->getStatus().message() != "Layer closed" &&
                            layer->getStatus().message() != "Layer disabled";

                        if (error)
                            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(ImColor(255, 72, 72))), stylePushed = true;
                        else if (!layer->isOpen())
                            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(ImColor(127, 127, 127))), stylePushed = true;

                        osgEarth::VisibleLayer* visibleLayer = dynamic_cast<osgEarth::VisibleLayer*>(layer);
                        if (visibleLayer)
                        {
                            if (layer->isOpen())
                            {
                                bool visible = visibleLayer->getVisible();
                                if (ImGui::Checkbox("", &visible))
                                {
                                    visibleLayer->setVisible(visible);
                                }
                            }
                            else // closed? the checkbox will try to open it.
                            {
                                bool dummy = false;
                                if (ImGui::Checkbox("", &dummy))
                                {
                                    layer->open();
                                }
                            }

                            ImGui::SameLine();

                            ImGui::PushID("selectable");
                            bool layerNameClicked = false;
                            if (layer->isOpen())
                            {
                                ImGui::Selectable(layer->getName().c_str(), &layerNameClicked);
                            }
                            else
                            {
                                std::string text = layer->getName() + " (closed)";
                                ImGui::Selectable(text.c_str(), &layerNameClicked);
                            }

                            if (layerNameClicked)
                            {
                                _layerExpanded[i] = !_layerExpanded[i];
                            }
                            ImGui::PopID(); // "selectable"
                        }
                        else
                        {
                            ImGui::Text(layer->getName().c_str());
                        }

                        if (_layerExpanded[i])
                        {
                            ImGui::Indent();

                            ImGui::TextColored(ImVec4(.8, .8, .8, 1), "%s", layer->className());

                            if (layer->isOpen())
                            {
                                auto elevationLayer = dynamic_cast<osgEarth::ElevationLayer*>(layer);
                                if (visibleLayer && !elevationLayer)
                                {
                                    float opacity = visibleLayer->getOpacity();
                                    if (ImGui::SliderFloat("Opacity", &opacity, 0.0f, 1.0f))
                                        visibleLayer->setOpacity(opacity);

                                    if (visibleLayer->options().maxVisibleRange().isSet())
                                    {
                                        float value = visibleLayer->getMaxVisibleRange();
                                        if (value < FLT_MAX) {
                                            if (ImGui::SliderFloat("Max range", &value, 0.0f, _maxMaxRanges[layer]))
                                                visibleLayer->setMaxVisibleRange(value);
                                        }
                                    }

                                    if (visibleLayer->options().minVisibleRange().isSet())
                                    {
                                        float value = visibleLayer->getMinVisibleRange();
                                        if (ImGui::SliderFloat("Min range", &value, 0.0f, _maxMinRanges[layer]))
                                            visibleLayer->setMinVisibleRange(value);
                                    }

                                    if (visibleLayer->options().attenuationRange().isSet())
                                    {
                                        float value = visibleLayer->getAttenuationRange();
                                        if (ImGui::SliderFloat("Attenuation range", &value, 0.0f, _maxAttenRanges[layer]))
                                            visibleLayer->setAttenuationRange(value);
                                    }

                                    bool debugView = visibleLayer->getEnableDebugView();
                                    if (ImGui::Checkbox("Highlight tiles", &debugView)) {
                                        visibleLayer->setEnableDebugView(debugView);
                                    }

                                    bool modulate = visibleLayer->getColorBlending() == BLEND_MODULATE;
                                    if (ImGui::Checkbox("Modulate", &modulate))
                                        visibleLayer->setColorBlending(modulate ? BLEND_MODULATE : BLEND_INTERPOLATE);
                                }

                                auto threedTiles = dynamic_cast<osgEarth::Contrib::ThreeDTilesLayer*>(layer);
                                if (threedTiles)
                                {
                                    float sse = threedTiles->getMaximumScreenSpaceError();
                                    ImGui::PushID("sse");
                                    ImGui::SliderFloat("SSE", &sse, 0.0f, 50.0f);
                                    threedTiles->setMaximumScreenSpaceError(sse);
                                    ImGui::PopID();

                                    ImGui::PushID("debugVolumes");
                                    bool showBoundingVolumes = threedTiles->getTilesetNode()->getShowBoundingVolumes();
                                    ImGui::Checkbox("Show debug volumes", &showBoundingVolumes);
                                    threedTiles->getTilesetNode()->setShowBoundingVolumes(showBoundingVolumes);
                                    ImGui::PopID();

                                    ImGui::PushID("debugColors");
                                    bool colorPerTile = threedTiles->getTilesetNode()->getColorPerTile();
                                    ImGui::Checkbox("Show color per tile", &colorPerTile);
                                    threedTiles->getTilesetNode()->setColorPerTile(colorPerTile);
                                    ImGui::PopID();
                                }

                                auto mapboxGLLayer = dynamic_cast<MapBoxGLImageLayer*>(layer);
                                if (mapboxGLLayer)
                                {
                                    bool disableText = mapboxGLLayer->getDisableText();
                                    if (ImGui::Checkbox("Disable text", &disableText))
                                    {
                                        mapboxGLLayer->setDisableText(disableText);
                                    }

                                    float pixelScale = mapboxGLLayer->getPixelScale();
                                    if (ImGui::InputFloat("Pixel Scale", &pixelScale))
                                    {
                                        mapboxGLLayer->setPixelScale(pixelScale);
                                    }
                                }


                                auto tileLayer = dynamic_cast<osgEarth::TileLayer*>(layer);
                                if (tileLayer)
                                {
                                    const Profile* profile = tileLayer->getProfile();
                                    if (profile)
                                    {
                                        std::string srsname = profile->getSRS()->getName();
                                        if (srsname == "unknown")
                                            srsname = profile->getSRS()->getHorizInitString();
                                        ImGui::TextColored(ImVec4(.8, .8, .8, 1), "%s", srsname.c_str());
                                    }

                                    if (tileLayer->options().minLevel().isSet())
                                    {
                                        ImGui::Text("Min level: %d", tileLayer->getMinLevel());
                                    }
                                    if (tileLayer->options().maxLevel().isSet())
                                    {
                                        ImGui::Text("Max level: %d", tileLayer->getMaxLevel());
                                    }
                                    if (tileLayer->options().maxDataLevel().isSet())
                                    {
                                        ImGui::Text("Max data level: %d", tileLayer->getMaxDataLevel());
                                    }

                                    if (tileLayer->options().upsample().isSetTo(true))
                                    {
                                        ImGui::Text("Upsampling is ON");
                                    }
                                    else if (tileLayer->options().upsample().isSetTo(false))
                                    {
                                        ImGui::Text("Upsampling is OFF");
                                    }
                                }
                                const GeoExtent& extent = layer->getExtent();
                                if (extent.isValid())
                                {
                                    ImGui::TextWrapped("W:%.1f E:%.1f S:%.1f N:%.1f",
                                        extent.west(), extent.east(), extent.south(), extent.north());
                                }

                                const DateTimeExtent& dtextent = layer->getDateTimeExtent();
                                if (dtextent.valid())
                                {
                                    ImGui::Text("Time Series:");
                                    ImGui::Text("  Start = %s", dtextent.getStart().asISO8601().c_str());
                                    ImGui::Text("  End   = %s", dtextent.getEnd().asISO8601().c_str());
                                }

                                auto imageLayer = dynamic_cast<ImageLayer*>(layer);
                                if (imageLayer)
                                {
                                    bool queryOn = (_queryLayer == imageLayer);
                                    if (ImGui::Checkbox("Show value under mouse", &queryOn))
                                    {
                                        _queryLayer = queryOn ? imageLayer : nullptr;
                                    }

                                    if (_queryLayer == imageLayer)
                                    {
                                        if (_imageLayerValueUnderMouse.isAvailable())
                                        {
                                            if (_imageLayerValueUnderMouse->isOK())
                                            {
                                                auto& value = _imageLayerValueUnderMouse->value();
                                                if (value.pixelFormat == GL_RGBA)
                                                {
                                                    auto& p = value.pixel;
                                                    ImGui::Text("  (%.2f %.2f %.2f %.2f)", p.r(), p.g(), p.b(), p.a());
                                                    ImGui::Text("  (%.2X %.2X %.2X %.2X)",
                                                        (int)(255.f*p.r()), (int)(255.f*p.g()), (int)(255.0f*p.b()), (int)(255.0f*p.a()));
                                                }
                                                else
                                                {
                                                    int v = (int)value.pixel.r();
                                                    ImGui::Text("  (%d)", v);
                                                    ImGui::Text("  (%#.8X)", v);
                                                }
                                            }
                                            else
                                            {
                                                ImGui::Text("%s", _imageLayerValueUnderMouse->message().c_str());
                                            }
                                        }
                                        else
                                        {
                                            ImGui::Text("  (searching)");
                                            ImGui::Text("");
                                        }
                                    }
                                }

                                if (extent.isValid() ||
                                    (layer->getNode() && layer->getNode()->getBound().valid()))
                                {
                                    if (ImGui::Button("Zoom to layer"))
                                    {
                                        if (extent.isValid())
                                        {
                                            std::vector<GeoPoint> points;
                                            points.push_back(GeoPoint(extent.getSRS(), extent.west(), extent.south()));
                                            points.push_back(GeoPoint(extent.getSRS(), extent.east(), extent.north()));

                                            ViewFitter fitter(map->getSRS(), camera);
                                            Viewpoint vp;
                                            if (fitter.createViewpoint(points, vp))
                                            {
                                                auto manip = dynamic_cast<EarthManipulator*>(view(ri)->getCameraManipulator());
                                                if (manip) manip->setViewpoint(vp, 2.0);
                                            }
                                        }
                                        else if (layer->getNode())
                                        {
                                            ViewFitter fitter(map->getSRS(), camera);
                                            Viewpoint vp;
                                            if (fitter.createViewpoint(layer->getNode(), vp))
                                            {
                                                auto manip = dynamic_cast<EarthManipulator*>(view(ri)->getCameraManipulator());
                                                if (manip) manip->setViewpoint(vp, 2.0);
                                            }
                                        }
                                    }
                                }

                                if (visibleLayer)
                                {
                                    if (ImGui::Button("Invalidate cache"))
                                    {
                                        layer->dirty();
                                        auto cp = layer->getCachePolicy();
                                        cp.minTime() = DateTime().asTimeStamp();
                                        layer->setCachePolicy(cp);
                                        std::vector<const Layer*> layers = { layer };
                                        _mapNode->getTerrainEngine()->invalidateRegion(layers, GeoExtent());
                                    }

                                    if (layer->isOpen())
                                    {
                                        ImGui::SameLine();
                                        if (ImGui::Button("Close layer"))
                                        {
                                            layer->close();
                                        }
                                    }
                                }
                            }

                            else if (layer->getStatus().isError() && layer->getStatus().message() != "Layer closed")
                            {
                                ImGui::TextWrapped(layer->getStatus().message().c_str());
                            }

                            ImGui::Unindent();
                        }

                        ImGui::PopID();

                        if (stylePushed)
                            ImGui::PopStyleColor(1);

                        ImGui::Separator();
                    }
                }
                ImGui::End();
            }


            void onMove(osg::View* view, float x, float y)
            {
                if (_queryLayer)
                {
                    _imageLayerValueUnderMouse.reset();

                    TerrainTile* tile = _mapNode->getTerrain()->getTerrainTileUnderMouse(view, x, y);
                    if (tile)
                    {
                        GeoPoint p = _mapNode->getGeoPointUnderMouse(view, x, y);
                        TileKey key = _queryLayer->getProfile()->createTileKey(p, tile->getKey().getLOD());
                        key = _queryLayer->getBestAvailableTileKey(key);

                        if (key.valid())
                        {
                            _imageLayerValueUnderMouse = Job().dispatch<Result<ValueUnderMouse>>([this, key, p](Cancelable* c)
                                {
                                    ValueUnderMouse value;
                                    osg::ref_ptr<ProgressCallback> prog = new ProgressCallback(c);
                                    GeoImage g = _queryLayer->createImage(key, prog.get());
                                    if (g.valid())
                                    {
                                        g.getReader().setBilinear(false);
                                        if (g.read(value.pixel, p))
                                        {
                                            value.pixelFormat = g.getImage()->getPixelFormat();
                                            return Result<ValueUnderMouse>(value);
                                        }
                                    }
                                    return Result<ValueUnderMouse>(Status::Error("No value"));
                                });
                        }
                    }
                }
            }
        };
    }
}

#endif // OSGEARTH_IMGUI_MAP_LAYERS_GUI
